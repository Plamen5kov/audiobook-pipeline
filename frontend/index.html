<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Audiobook Generator</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --bg: #0f1117;
      --surface: #1a1d27;
      --surface2: #22263a;
      --border: #2e3354;
      --accent: #6c63ff;
      --accent-hover: #7d75ff;
      --text: #e8e9f0;
      --text-dim: #8b8fa8;
      --success: #4caf7d;
      --warning: #f0a500;
      --error: #e05252;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 40px 20px 80px;
    }

    header {
      text-align: center;
      margin-bottom: 40px;
    }

    header h1 {
      font-size: 2rem;
      font-weight: 700;
      letter-spacing: -0.5px;
    }

    header h1 span { color: var(--accent); }

    header p {
      color: var(--text-dim);
      margin-top: 8px;
      font-size: 0.95rem;
    }

    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 28px;
      width: 100%;
      max-width: 720px;
      margin-bottom: 20px;
    }

    .card h2 {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      margin-bottom: 18px;
    }

    .card .subtitle {
      font-size: 0.875rem;
      color: var(--text-dim);
      margin-top: -10px;
      margin-bottom: 20px;
    }

    label {
      display: block;
      font-size: 0.875rem;
      color: var(--text-dim);
      margin-bottom: 6px;
    }

    input[type="text"], textarea, select {
      width: 100%;
      background: var(--surface2);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 0.95rem;
      padding: 10px 14px;
      outline: none;
      transition: border-color 0.2s;
      font-family: inherit;
    }

    input[type="text"]:focus, textarea:focus, select:focus {
      border-color: var(--accent);
    }

    textarea {
      resize: vertical;
      min-height: 220px;
      line-height: 1.6;
    }

    .field { margin-bottom: 18px; }
    .field:last-child { margin-bottom: 0; }

    button.primary {
      width: 100%;
      padding: 14px;
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s, opacity 0.2s;
    }

    button.primary:hover:not(:disabled) { background: var(--accent-hover); }
    button.primary:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Progress */
    #progress-card { display: none; }

    .phase-list { list-style: none; }

    .phase-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.95rem;
    }

    .phase-item:last-child { border-bottom: none; }

    .phase-icon {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 0.8rem;
    }

    .phase-icon.pending  { background: var(--surface2); color: var(--text-dim); }
    .phase-icon.running  { background: var(--accent); color: #fff; }
    .phase-icon.done     { background: var(--success); color: #fff; }
    .phase-icon.error    { background: var(--error); color: #fff; }

    .phase-label { flex: 1; }
    .phase-label .name { font-weight: 500; }
    .phase-label .detail { font-size: 0.8rem; color: var(--text-dim); margin-top: 2px; }

    .spinner {
      display: inline-block;
      width: 14px;
      height: 14px;
      border: 2px solid rgba(255,255,255,0.4);
      border-top-color: #fff;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    /* Voice cast */
    #voice-cast-card { display: none; }

    .cast-row {
      display: flex;
      align-items: flex-start;
      gap: 14px;
      padding: 14px 0;
      border-bottom: 1px solid var(--border);
    }

    .cast-row:last-of-type { border-bottom: none; }

    .cast-speaker {
      width: 110px;
      flex-shrink: 0;
      font-weight: 500;
      font-size: 0.95rem;
      padding-top: 6px;
    }

    .voice-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      flex: 1;
    }

    .voice-chip {
      display: inline-flex;
      align-items: center;
      gap: 0;
      border: 1px solid var(--border);
      border-radius: 20px;
      overflow: hidden;
      cursor: pointer;
      font-size: 0.82rem;
      transition: border-color 0.15s;
      background: var(--surface2);
    }

    .voice-chip:hover { border-color: var(--accent); }

    .voice-chip.selected {
      border-color: var(--accent);
      background: color-mix(in srgb, var(--accent) 15%, var(--surface2));
    }

    .voice-chip .chip-play {
      padding: 6px 8px 6px 10px;
      color: var(--text-dim);
      background: transparent;
      border: none;
      cursor: pointer;
      font-size: 0.75rem;
      transition: color 0.15s;
      line-height: 1;
    }

    .voice-chip:hover .chip-play,
    .voice-chip.selected .chip-play { color: var(--accent); }

    .voice-chip.playing .chip-play { color: var(--accent); }

    .voice-chip .chip-name {
      padding: 6px 10px 6px 4px;
      color: var(--text-dim);
      user-select: none;
    }

    .voice-chip.selected .chip-name { color: var(--text); font-weight: 500; }

    .cast-actions {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
    }

    /* Result */
    #result-card { display: none; }

    .audio-player {
      width: 100%;
      margin-bottom: 14px;
      accent-color: var(--accent);
    }

    .download-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 20px;
      background: var(--success);
      color: #fff;
      border-radius: 8px;
      text-decoration: none;
      font-weight: 600;
      font-size: 0.95rem;
      transition: opacity 0.2s;
    }

    .download-btn:hover { opacity: 0.85; }

    .error-msg {
      color: var(--error);
      font-size: 0.9rem;
      margin-top: 12px;
    }
  </style>
  <script src="config.js"></script>
</head>
<body>

<header>
  <h1>Audiobook <span>Generator</span></h1>
  <p>Paste your chapter text and generate a fully narrated audiobook with distinct character voices.</p>
</header>

<!-- Input -->
<div class="card" id="input-card">
  <h2>Chapter Input</h2>
  <div class="field">
    <label for="title">Chapter Title</label>
    <input type="text" id="title" placeholder="e.g. Chapter 1: The Awakening" value="Chapter 1: The Awakening">
  </div>
  <div class="field">
    <label for="text">Chapter Text</label>
    <textarea id="text" placeholder="Paste your chapter text here..."></textarea>
  </div>
  <div class="field">
    <button class="primary" id="generate-btn" onclick="generate()">Analyze Text</button>
  </div>
  <p id="error-msg" class="error-msg" style="display:none"></p>
</div>

<!-- Progress -->
<div class="card" id="progress-card">
  <h2>Progress</h2>
  <ul class="phase-list">
    <li class="phase-item" id="phase-analyzing">
      <div class="phase-icon pending" id="icon-analyzing">1</div>
      <div class="phase-label">
        <div class="name">Analyzing text</div>
        <div class="detail" id="detail-analyzing">Identifying speakers, emotions, and segments…</div>
      </div>
    </li>
    <li class="phase-item" id="phase-synthesizing">
      <div class="phase-icon pending" id="icon-synthesizing">2</div>
      <div class="phase-label">
        <div class="name">Synthesizing audio</div>
        <div class="detail" id="detail-synthesizing">Waiting for analysis to complete…</div>
      </div>
    </li>
    <li class="phase-item" id="phase-assembling">
      <div class="phase-icon pending" id="icon-assembling">3</div>
      <div class="phase-label">
        <div class="name">Assembling final file</div>
        <div class="detail" id="detail-assembling">Waiting…</div>
      </div>
    </li>
  </ul>
</div>

<!-- Voice Cast -->
<div class="card" id="voice-cast-card">
  <h2>Voice Cast</h2>
  <p class="subtitle">Assign a reference voice to each character, then start synthesis.</p>
  <div id="cast-rows"></div>
  <div class="cast-actions">
    <button class="primary" id="synthesize-btn" onclick="startSynthesis()">Generate Audiobook</button>
  </div>
</div>

<!-- Result -->
<div class="card" id="result-card">
  <h2>Your Audiobook</h2>
  <audio class="audio-player" id="audio-player" controls></audio>
  <a id="download-link" class="download-btn" href="#" download>
    &#8595; Download WAV
  </a>
</div>

<script>
const API = (window.PIPELINE_API || '').replace(/\/$/, '');

let pollTimer   = null;
let currentJobId = null;
let pendingSegments = null;
let availableVoices = [];
let previewAudio = new Audio();

function uuid() {
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
}

function setPhase(id, state, detail) {
  const icon = document.getElementById('icon-' + id);
  const det  = document.getElementById('detail-' + id);
  icon.className = 'phase-icon ' + state;
  if (state === 'running') icon.innerHTML = '<span class="spinner"></span>';
  else if (state === 'done')  icon.textContent = '✓';
  else if (state === 'error') icon.textContent = '✗';
  else if (state === 'pending') icon.textContent = icon.textContent || '';
  if (detail) det.textContent = detail;
}

function showError(msg) {
  const el = document.getElementById('error-msg');
  el.textContent = msg;
  el.style.display = 'block';
  document.getElementById('generate-btn').disabled = false;
  stopPolling();
}

function stopPolling() {
  if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
}

async function generate() {
  const title = document.getElementById('title').value.trim();
  const text  = document.getElementById('text').value.trim();

  if (!text) { alert('Please paste chapter text first.'); return; }

  document.getElementById('error-msg').style.display = 'none';
  document.getElementById('generate-btn').disabled = true;
  document.getElementById('result-card').style.display = 'none';
  document.getElementById('voice-cast-card').style.display = 'none';
  document.getElementById('progress-card').style.display = 'block';

  setPhase('analyzing',    'running', 'Sending to LLM for analysis…');
  setPhase('synthesizing', 'pending', 'Waiting for analysis to complete…');
  setPhase('assembling',   'pending', 'Waiting…');

  const jobId = uuid();
  currentJobId = jobId;

  // Pre-fetch available voices so the cast UI is ready instantly
  availableVoices = await fetch(`${API}/voices`).then(r => r.json()).catch(() => []);

  try {
    const res = await fetch(`${API}/api/analyze`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ title, text, job_id: jobId }),
    });
    if (!res.ok) throw new Error(`Analyze error: ${res.status}`);
  } catch (e) {
    showError('Failed to reach the pipeline. Is n8n running? ' + e.message);
    return;
  }

  pollTimer = setInterval(() => poll(jobId), 4000);
}

async function poll(jobId) {
  if (jobId !== currentJobId) return;
  let status;
  try {
    const res = await fetch(`${API}/status/${jobId}`);
    if (res.status === 404) return;
    if (!res.ok) throw new Error(res.status);
    status = await res.json();
  } catch (e) {
    return;
  }

  const { phase, status: st, segments, total, output_file, error } = status;

  if (error) {
    setPhase('analyzing', 'error', error);
    showError('Pipeline error: ' + error);
    return;
  }

  if (phase === 'analyzing') {
    if (st === 'running') {
      setPhase('analyzing', 'running', 'LLM is parsing the chapter…');
    } else if (st === 'done') {
      stopPolling();
      const segCount = segments ? segments.length : '?';
      setPhase('analyzing', 'done', `Found ${segCount} segments`);
      pendingSegments = segments;
      showVoiceCast(segments);
    }
  } else if (phase === 'synthesizing') {
    if (st === 'running') {
      const info = total ? `${total} segments` : '';
      setPhase('synthesizing', 'running', `Generating voices${info ? ' — ' + info : ''}…`);
    } else if (st === 'done') {
      setPhase('synthesizing', 'done', 'All segments synthesized');
      setPhase('assembling',   'running', 'Joining audio clips…');
    }
  } else if (phase === 'done') {
    setPhase('synthesizing', 'done', 'All segments synthesized');
    setPhase('assembling',   'done', 'Audiobook ready');
    stopPolling();
    showResult(output_file);
  }
}

// ── Voice cast UI ──────────────────────────────────────────────

function showVoiceCast(segments) {
  const speakers = [...new Set((segments || []).map(s => s.speaker).filter(Boolean))];
  const container = document.getElementById('cast-rows');
  container.innerHTML = '';

  const voices = availableVoices.length > 0
    ? availableVoices
    : [{ name: 'generic_neutral', filename: 'generic_neutral.wav' }];

  speakers.forEach((speaker, i) => {
    const defaultFilename = pickDefaultVoice(speaker, i);
    const row = document.createElement('div');
    row.className = 'cast-row';

    const chipsHtml = voices.map(v => `
      <div class="voice-chip ${v.filename === defaultFilename ? 'selected' : ''}"
           data-filename="${escHtml(v.filename)}"
           data-speaker="${escHtml(speaker)}"
           onclick="selectChip(this)">
        <button class="chip-play"
                onclick="event.stopPropagation(); togglePreview(this.parentElement)"
                title="Preview ${escHtml(v.name)}">▶</button>
        <span class="chip-name">${escHtml(v.name)}</span>
      </div>`).join('');

    row.innerHTML = `
      <div class="cast-speaker">${escHtml(speaker)}</div>
      <div class="voice-chips">${chipsHtml}</div>
    `;
    container.appendChild(row);
  });

  document.getElementById('voice-cast-card').style.display = 'block';
  document.getElementById('synthesize-btn').disabled = false;
}

function pickDefaultVoice(speaker, index) {
  if (availableVoices.length === 0) return 'generic_neutral.wav';
  const lower = speaker.toLowerCase();
  const exact = availableVoices.find(v => v.name.toLowerCase() === lower);
  return exact ? exact.filename : availableVoices[index % availableVoices.length].filename;
}

function selectChip(chip) {
  // Deselect sibling chips for this speaker
  chip.closest('.voice-chips').querySelectorAll('.voice-chip').forEach(c => c.classList.remove('selected'));
  chip.classList.add('selected');
}

function togglePreview(chip) {
  const filename = chip.dataset.filename;
  const playBtn  = chip.querySelector('.chip-play');

  // Stop if already playing this chip
  if (!previewAudio.paused && previewAudio.dataset.file === filename) {
    previewAudio.pause();
    clearPlayingState();
    return;
  }

  // Stop any other playing chip
  clearPlayingState();

  previewAudio.src = `${API}/voices/${filename}`;
  previewAudio.dataset.file = filename;
  previewAudio.play();
  chip.classList.add('playing');
  playBtn.textContent = '⏹';

  previewAudio.onended = clearPlayingState;
}

function clearPlayingState() {
  document.querySelectorAll('.voice-chip.playing').forEach(c => {
    c.classList.remove('playing');
    c.querySelector('.chip-play').textContent = '▶';
  });
}

async function startSynthesis() {
  document.getElementById('synthesize-btn').disabled = true;
  document.getElementById('voice-cast-card').style.display = 'none';
  previewAudio.pause();

  // Read voice mapping from selected chips
  const voiceMap = {};
  document.querySelectorAll('.voice-chip.selected').forEach(chip => {
    voiceMap[chip.dataset.speaker] = chip.dataset.filename;
  });

  setPhase('synthesizing', 'running', 'Sending to voice synthesis…');

  try {
    const res = await fetch(`${API}/api/synthesize`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ segments: pendingSegments, voice_mapping: voiceMap, job_id: currentJobId }),
    });
    if (!res.ok) throw new Error(`Synthesize error: ${res.status}`);
  } catch (e) {
    showError('Failed to start synthesis: ' + e.message);
    return;
  }

  pollTimer = setInterval(() => poll(currentJobId), 4000);
}

// ── Result ─────────────────────────────────────────────────────

function showResult(filename) {
  const src = `${API}/audio/${filename}`;
  document.getElementById('audio-player').src = src;
  document.getElementById('download-link').href = src;
  document.getElementById('download-link').download = filename;
  document.getElementById('result-card').style.display = 'block';
  document.getElementById('generate-btn').disabled = false;
  document.getElementById('generate-btn').textContent = 'Analyze Text';
}

function escHtml(s) {
  return String(s).replace(/[&<>"']/g, c =>
    ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}
</script>

</body>
</html>
